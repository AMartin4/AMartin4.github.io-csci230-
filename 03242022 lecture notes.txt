Computer does computations

Arithmetic operations: + - * /

addition = s sequence of single-digit adder

subtraction x-y = x+(-y) = x+flip(y)

multiplication = multiplicand+multiplier 

multiplier: a sequence pf copy, shifting, adding

multiplier0 = multiplier<<31>>31

_____________________________________________________________________________________________________

import java.awt.Font;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import javax.swing.*;
import javax.swing.SwingUtilities;

/**
 * @author Azyah Martin
 */
public class ArithmeticSimulator 
{
   static final char [] ZERO = new char[]{
   '0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0',
   '0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0',
   '0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0',
   '0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'};
   static void copy(char []x, char [] y)
   { 
       for (int i=0; i < x.length && i < y.length; i++)
       y[i] = x[i];
   }
   static void copyLow(char []x, char [] y)
   { 
       int i,j;
       for (i=y.length-1,j=x.length-1; i>=0 && j>=0; i--,j--)
          y[i] = x[j];
   }
   static void clear(char [] x)
   {
       copy(ZERO,x);
   }
   static void set(char [] x, int position, char v)
   {
       x[position] = v;
   }
    static boolean negativeTest(char []x)
   {
       return x[0] == '1';
   }
   static void shiftleft(char x[])
   {
      for (int i=0; i < x.length-1; i++)
          x[i] = x[i+1];
      x[x.length-1] = '0';
   }
   static void shiftright(char x[])
   {
      for (int i=x.length-1; i >1; i--)
          x[i] = x[i-1];
      x[0] = '0';
   }
   static char[] singleDigitAdd(char a, char b, char carryover)
   {
      char sum = '0';
      if (a == '0' && b == '0' && carryover == '0'){sum = '0';carryover='0';}
      else if (a == '0' && b == '0' && carryover == '1'){sum = '1';carryover='0';}
      else if (a == '0' && b == '1' && carryover == '0'){sum = '1';carryover='0';}
      else if (a == '0' && b == '1' && carryover == '1'){sum = '0';carryover='1';}
      else if (a == '1' && b == '0' && carryover == '0'){sum = '1';carryover='0';}
      else if (a == '1' && b == '0' && carryover == '1'){sum = '0';carryover='1';}
      else if (a == '1' && b == '1' && carryover == '0'){sum = '0';carryover='1';}
      else if (a == '1' && b == '1' && carryover == '1'){sum = '1';carryover='1';}
      return new char[]{sum,  carryover};
   }
   //add y to x, x updated
   static void add(char x[], char y[])  
   {
      char carryover = '0';
      if (y.length < x.length)
       {
           char z[] = new char[x.length];
           copy(ZERO,z);
           copyLow(y,z);
           y = z;
       }
      for (int i=x.length-1; i>=0; i--)
      {
         char [] sumcarryover = singleDigitAdd(x[i], y[i], carryover);
         x[i] = sumcarryover[0];
         carryover = sumcarryover[1];
      }
   }
   static void flip(char x[])
   {
       for (int i=0; i < x.length; i++)
       if (x[i] == '1') 
           x[i] = '0';
       else 
           x[i] = '1';
   }
  // a - b = a + (-b) = a + (flip + addone)
   static void subtract(char x[], char y[]) //  subt y from  x
   { 
       char z[] = new char[x.length]; 
       if (y.length < x.length)
       {
           clear(z);
           copyLow(y,z);
       }
       else
           copy(y,z);
       flip(z);
       char one[] = new char[x.length];
       copy(ZERO, one);
       set(one, one.length-1, '1');
       add(z, one);
       add(x,z);
   }
  
   /*
(1) The Multiplicand register, ALU, and Product register are all 64 bits wide, with only the Multiplier register containing 32 bits.
(2) The multiplication operation starts with the product initialized to 0. The 32-bit multiplicand starts in the right half of the Multiplicand register.
(3) Control checks Multiplier0 to determine when to shift the Multiplicand and Multiplier registers and when to write new values into the Product register.
(4) If Multiplier0 is 0, then Multiplicand register is shifted left 1 bit and the Multiplier is shifted right 1 bit.
(5) If Multiplier0 is 1, then Multiplicand and product registers are added and placed in the Product register.
(6) The Multiplicand register is again shifted left 1 bit and the Multiplier is shifted right 1 bit.
(7) Process continues 32 times to obtain the product.
   */
   
   static char [] multiply(char [] multiplicand, char [] multiplier)
   {   
      char [] Multiplicand = new char[64]; //(1)
      char [] Product = new char[64];
      char [] Multiplier = new char[32];
      
      copy(ZERO,Product);  //(2)
      copy(ZERO,Multiplicand);
      copyLow(multiplicand, Multiplicand);
      copy(multiplier,Multiplier);
       
      for(int i=0; i < 32; i++)  //(7)
      {
          char Multiplier0 = Multiplier[31]; //(3)
          if (Multiplier0 == '0')      //(3)
          {
             shiftleft(Multiplicand);  //(4)
             shiftright(Multiplier);
          }
          else
          {
             add(Product, Multiplicand);//(5)
             showbits(Product);
             shiftleft(Multiplicand);   //(6)
             shiftright(Multiplier);    //(7)
          }
      }
      return Product;
   }
    /*(1)The Divisor register, ALU, and Remainder register are all 64 bits wide, with only the Quotient register being 32 bits.
(2) The divisor is placed in the left half of Divisor register, 
(3) the dividend is placed in the Remainder, and the Quotient is set to 0.
(4) The Divisor is subtracted from the Remainder, then the result is placed into the Remainder.
(5) If the result is negative, then the Remainder value is restored by adding the divisor to the Remainder.
(6) A negative Remainder indicates the divisor did not go into the dividend. Control shifts Quotient left 1 bit and places a 0 in the least significant bit.
(7) Divisor is shifted right 1 bit and the divide operation repeats.
(8) The Divisor is subtracted from the Remainder, then the result is placed into the Remainder.
(9) If the Remainder is positive, then the divisor was smaller or equal to the dividend. Control shifts Quotient left 1 bit and places a 1 in the least significant bit.
(10) Divisor is shifted right 1 bit and the divide operation repeats. The steps repeat a total of 33 times.
*/
   static char [][] divide(char dividend[], char divisor[])
   {
       char [] Divisor = new char[64]; //(1)
       char [] Remainder = new char[64];//(1)
       char [] quotient = new char[32]; //(1)
       
       copy(ZERO,Divisor);    //(2)
       copy(divisor, Divisor);//(2)
       copy(dividend, Remainder);  //(3)
       copy(ZERO, quotient); //(3)
          
       for(int round = 0; round < 33; round++) //(7)(10)
       {
               subtract(Remainder, Divisor); //(4)(8)
               showbits(Remainder);
               if (negativeTest(Remainder))  //(5)
               {
                  sb.append("\n");sb.append("-");
                  add(Remainder, Divisor);   //(5)
                  shiftleft(quotient);       //(6)
                  shiftright(Divisor);       //(6)
               }
               else
               {
                   sb.append("\n");sb.append("+");
                   shiftleft(quotient);      
                   set(quotient,31, '1');    //(9)
                   shiftright(Divisor);      //(9)
               }
           
       }
       return new char[][]{quotient, Remainder};
   }
   static void showbits(char []x)
   {
      sb.append("\n");sb.append(x);
   }
   static char [] itobits(int i, int many)
   {
      char [] x = new char[many];
      copy(ZERO,x);
      while(i != 0)
      {
          int m = i%2;
          x[--many] = m==0?'0':'1';
          i = i >> 1;
      }
      return x;
   }
   static int bits2i(char [] x)
   {
      int ans = 0;
      for(int i=0; i < x.length; i++)
      {
         ans = ans << 1;
         ans += x[i]=='1'?1:0;
      }
      return ans;
   }
   public static void main(String args[])
   {
      SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                JFrame frame = new JFrame();
                JTextArea t = new JTextArea(23,70);
                t.setFont(new Font("monospaced", Font.BOLD, 14));
                JScrollPane sp=new JScrollPane(t);
                frame.getContentPane().add(sp);
                test();
                t.append(sb.toString());
                try {
              InputStream in = this.getClass().getClassLoader().getResourceAsStream("resources/ArithmeticSimulator.txt");
              BufferedReader r = new BufferedReader(new InputStreamReader(in));
              String aline = null;
              int jj = 0, kk=0;
              StringBuffer s = new StringBuffer();
              while ( (aline = r.readLine())!= null)
              {
                  t.append(aline + "\n");
              }
              r.close();
              in.close();
            } catch (Exception e) {
                System.out.println(e.toString());
            }
                frame.pack();
                frame.setTitle("Arithmetic  Simulator");
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
      
   }
   static StringBuilder sb;
   public static void test()
   {
       int N = 10000;
       int [] x = new int[N];
       
       for (int i=0; i < N; i++)
       {
           x[i] = 1+(int)(Math.random()*1000000);
       }
       int s=0;
       long t, t0;
       t0 = System.nanoTime();
       for (int i=0; i < N; i++) 
           for (int j= 0; j < N; j++)
              s += x[i] + x[j];
       t = System.nanoTime() - t0;
       sb = new StringBuilder();
       sb.append("Test 1: Comparison of Speed of Arithmetics");
       sb.append("\n");sb.append("Time spent on " + (N*N) + "       additions: " + t);
       t0 = System.nanoTime();
       for (int i=0; i < N; i++) 
           for (int j= 0; j < N; j++)
              s += x[i] - x[j];
       t = System.nanoTime() - t0;
       sb.append("\n");sb.append("Time spent on " + (N*N) + "    subtractions: " + t);
       t0 = System.nanoTime();
       for (int i=0; i < N; i++) 
           for (int j= 0; j < N; j++)
              s += x[i] * x[j];
       t = System.nanoTime() - t0;
       sb.append("\n");sb.append("Time spent on " + (N*N) + " multiplications: " + t);
       t0 = System.nanoTime();
       for (int i=0; i < N; i++) 
           for (int j= 0; j < N; j++)
              s += x[i] / x[j];
       t = System.nanoTime() - t0;
       sb.append("\n");sb.append("Time spent on " + (N*N) + "       divisions: " + t);
       System.out.println(s);
       
      sb.append("\n\nTest 2: Correctness of Addition and Subtraction");
       
      int dividendi = 4785963; 
      char [] dividend = itobits(dividendi, 64);
      sb.append("\n");sb.append("     x=" + dividendi);showbits(dividend);
      int divisori = 562;
      char [] divisor = itobits(divisori, 32);
      sb.append("\n");sb.append("     y=" +divisori );showbits(divisor);
      sb.append("\n");sb.append("   actural sum = x+y = " + (dividendi+divisori));
      add(dividend,divisor);
      sb.append("\n");sb.append("       simulated sum = " + bits2i(dividend));
      sb.append("\n");sb.append("actural  sum - y = x = " + (dividendi));
      subtract(dividend,divisor);
      sb.append("\n");sb.append("   simulated sum - y = " + bits2i(dividend));
       
      sb.append("\n\nTest 3: Correctness of Division");
      char [][] y = divide(dividend, divisor);
      char [] quotient = y[0];
      char [] remainder = y[1];
      int quotienti = bits2i(quotient);
      int remainderi = bits2i(remainder);
      sb.append("\n");sb.append("simulated quotient x/y = " + quotienti + ", remainder=" + remainderi);
      sb.append("\n");sb.append("      actural quotient = " + (dividendi/divisori) + ", remainder=" + (dividendi%divisori));
      
      sb.append("\n\nTest 4: Correctness of Multiplication");
      char product[] = multiply(divisor, quotient);
      int producti = bits2i(product) ;
      sb.append("\n");sb.append("simulated product quotient*y = " + producti  );
      sb.append("\n");sb.append(" actural product  quotient*y = " + (quotienti*divisori) );
      sb.append("\n\nSource Codes: ArithmeticSimulator.java\n\n");
       
   }
}

_____________________________________________________________________________________________________

Exception in thread "AWT-EventQueue-0" 
java.awt.HeadlessException: 
No X11 DISPLAY variable was set, but this program performed an operation which requires it.
	at java.desktop/java.awt.GraphicsEnvironment.checkHeadless(GraphicsEnvironment.java:208)
	at java.desktop/java.awt.Window.<init>(Window.java:548)
	at java.desktop/java.awt.Frame.<init>(Frame.java:423)
	at java.desktop/java.awt.Frame.<init>(Frame.java:388)
	at java.desktop/javax.swing.JFrame.<init>(JFrame.java:180)
	at ArithmeticSimulator$1.run(ArithmeticSimulator.java:225)
	at java.desktop/java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:313)
	at java.desktop/java.awt.EventQueue.dispatchEventImpl(EventQueue.java:770)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:721)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:715)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:85)
	at java.desktop/java.awt.EventQueue.dispatchEvent(EventQueue.java:740)
	at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:203)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:124)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:113)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:109)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)
	at java.desktop/java.awt.EventDispatchThread.run(EventDispatchThread.java:90)


** Process exited - Return Code: 0 **
